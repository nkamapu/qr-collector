<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QR Collector — iPhone連続読み取り</title>
  <style>
    body{font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";margin:16px;}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    button{padding:8px 12px;border:1px solid #ccc;border-radius:8px;background:#f6f6f6}
    button:active{transform:scale(0.98)}
    input,select{padding:8px;border:1px solid #ccc;border-radius:8px}
    #log{white-space:pre-wrap;background:#fafafa;border:1px solid #eee;border-radius:8px;padding:8px;min-height:120px}
    #counter{font-weight:600}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#eef;border:1px solid #ccd}
    .muted{color:#666}
  </style>
  <script src="https://unpkg.com/html5-qrcode"></script>
</head>
<body>
  <h1 style="margin:0 0 8px">QR Collector</h1>
  <p class="muted" style="margin-top:0">iPhoneのSafariで開き、カメラ許可→連続読み取り→CSV/TXT保存 or 任意URLへPOST。</p>

  <div class="row" style="margin:12px 0">
    <button id="btn-start">スキャン開始</button>
    <button id="btn-stop" disabled>停止</button>
    <label class="row">区切り
      <select id="sep">
        <option value=",">,（カンマ）</option>
        <option value="\n">改行</option>
      </select>
    </label>
    <label class="row"><input type="checkbox" id="dedup"/> 重複を除外</label>
    <label class="row"><input type="checkbox" id="trim" checked/> 前後空白を除去</label>
  </div>

  <div id="reader" style="width: 100%; max-width: 520px"></div>

  <div style="margin:12px 0" class="row">
    <span>件数: <span id="counter">0</span></span>
    <span class="pill" id="last">last: -</span>
  </div>

  <div class="row" style="margin:12px 0">
    <button id="btn-undo">1件戻す</button>
    <button id="btn-clear">クリア</button>
    <button id="btn-copy">クリップボードにコピー</button>
    <button id="btn-dl-csv">CSV保存</button>
    <button id="btn-dl-txt">TXT保存</button>
  </div>

  <details style="margin:12px 0">
    <summary>PCへHTTP POST（任意）</summary>
    <div class="row" style="margin-top:8px">
      <input id="post-url" placeholder="https://pc.example.local:5000/upload" style="min-width:280px"/>
      <button id="btn-post">送信</button>
      <span class="muted">本文: rawテキスト（ヘッダ Content-Type: text/plain）</span>
    </div>
  </details>

  <h3 style="margin:12px 0 4px">プレビュー</h3>
  <div id="log"></div>

  <script>
    // 状態
    let items = [];
    let running = false;
    let html5QrCode = null; // will hold Html5Qrcode instance

    // === beep 音関連 ===
    let audioCtx = null;
    function ensureAudio(){
      if(!audioCtx){
        try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(_){ audioCtx = null; }
      }
      // iOSで停止状態なら再開（ユーザー操作中にのみ可能）
      if(audioCtx && audioCtx.state === 'suspended') { audioCtx.resume().catch(()=>{}); }
    }
    let lastBeep = 0;
    function beep(){
      if(!audioCtx) return;
      const now = Date.now();
      if(now - lastBeep < 120) return; // 連続検出の鳴り過ぎ防止
      lastBeep = now;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      o.frequency.value = 880; // A5
      g.gain.setValueAtTime(0.001, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.08, audioCtx.currentTime + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.15);
      o.connect(g).connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + 0.18);
    }

    const els = {
      start: document.getElementById('btn-start'),
      stop: document.getElementById('btn-stop'),
      sep: document.getElementById('sep'),
      dedup: document.getElementById('dedup'),
      trim: document.getElementById('trim'),
      reader: document.getElementById('reader'),
      counter: document.getElementById('counter'),
      last: document.getElementById('last'),
      undo: document.getElementById('btn-undo'),
      clear: document.getElementById('btn-clear'),
      copy: document.getElementById('btn-copy'),
      dlCsv: document.getElementById('btn-dl-csv'),
      dlTxt: document.getElementById('btn-dl-txt'),
      postUrl: document.getElementById('post-url'),
      post: document.getElementById('btn-post'),
      log: document.getElementById('log')
    };

    function updateUI() {
      els.counter.textContent = String(items.length);
      els.last.textContent = 'last: ' + (items[items.length - 1] ?? '-');
      const sep = els.sep.value;
      els.log.textContent = items.join(sep);
    }

    function pushItem(val){
      const t = els.trim.checked ? (val ?? '').trim() : (val ?? '');
      if (!t) return;
      if (els.dedup.checked && items.includes(t)) return;
      items.push(t);
      updateUI();
    }

    async function startScan(){
      if (running) return;
      running = true;
      els.start.disabled = true;
      els.stop.disabled = false;

      // ユーザー操作中にAudioContextを初期化
      ensureAudio();

      // カメラの選択（背面優先）
      const cameras = await Html5Qrcode.getCameras();
      const backCam = cameras.find(c => /back|rear|environment/i.test(c.label)) || cameras[0];
      if (!backCam) { alert('カメラが見つかりません'); stopScan(); return; }

      html5QrCode = new Html5Qrcode('reader', { formatsToSupport: [ Html5QrcodeSupportedFormats.QR_CODE ]});

      const onSuccess = (decodedText, decodedResult) => {
        pushItem(decodedText);
        beep();
        // デフォルトで連続読み取り
      };
      const onFail = (err) => { /* 読み取り失敗は無視（連続化） */ };

      const config = { fps: 15, qrbox: (viewWidth, viewHeight)=>{
        const size = Math.min(350, Math.floor(Math.min(viewWidth, viewHeight)*0.8));
        return { width: size, height: size };
      }};

      try{
        await html5QrCode.start({ facingMode: { exact: "environment" } }, config, onSuccess, onFail);
      }catch(e){
        // facingMode指定が失敗した場合はIDで再試行
        await html5QrCode.start(backCam.id, config, onSuccess, onFail);
      }
    }

    async function stopScan(){
      if (!running) return;
      running = false;
      els.start.disabled = false;
      els.stop.disabled = true;
      if (html5QrCode){
        try { await html5QrCode.stop(); } catch(_){}
        try { await html5QrCode.clear(); } catch(_){}
        html5QrCode = null;
      }
    }

    function download(filename, text){
      const blob = new Blob([text], {type: 'text/plain;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.click();
      URL.revokeObjectURL(url);
    }

    async function copyToClipboard(text){
      try{ await navigator.clipboard.writeText(text); alert('コピーしました'); }
      catch(e){ alert('コピーに失敗: ' + e); }
    }

    // events
    els.start.onclick = startScan;
    els.stop.onclick = stopScan;
    els.undo.onclick = () => { items.pop(); updateUI(); };
    els.clear.onclick = () => { if(confirm('全て削除しますか？')) { items = []; updateUI(); } };
    els.copy.onclick = () => copyToClipboard(items.join(els.sep.value));
    els.dlCsv.onclick = () => download('qrdata.csv', items.join(','));
    els.dlTxt.onclick = () => download('qrdata.txt', items.join(els.sep.value));
    els.sep.onchange = updateUI;

    els.post.onclick = async () => {
      const url = (els.postUrl.value || '').trim();
      if(!url){ alert('URLを入力してください'); return; }
      const body = items.join(els.sep.value);
      try{
        const res = await fetch(url, { method:'POST', headers:{'Content-Type':'text/plain'}, body });
        alert('送信: ' + res.status + ' ' + res.statusText);
      }catch(e){ alert('送信エラー: '+ e); }
    };

    // 初期描画
    updateUI();

    // iOSヒント
    console.log('iOS SafariではHTTPSまたはlocalhostでのカメラアクセスが必要です。ホーム画面に追加でUIが広くなります。');
  </script>
</body>
</html>

